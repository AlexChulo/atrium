import java.nio.file.Path
import java.util.regex.Pattern

def createGenerateLogicTask(Project project, String suffix = '') {
    String packagePath = "ch/tutteli/atrium/scala2/logic" + (suffix != '' ? "/" + suffix : '')
    String generatedFolder = project.generatedFolder

    return task('generateLogic', description: 'generates ext. methods for AssertionContainer based on interfaces') {
        String kotlinPackagePath = packagePath.replace('scala2/', '')
        def pathToInterfaces = "$project.projectDir/../../../logic/atrium-logic-common/src/main/kotlin/$kotlinPackagePath/"
        def interfaces = getInterfaces(pathToInterfaces)
        def generatedPath = "$project.projectDir/$generatedFolder/$packagePath"
        inputs.files(interfaces)
        outputs.dir(generatedPath)

        doFirst {

            //TODO delete all files in folder first (as we might have removed things)
            String ln = ln()
            String header = header()

            def identifier = /[a-zA-Z0-9]+/
            def newLine = /(?:\r\n?|\n)/
            def newLineAndIndent = /$newLine\s*/
            def firstTypeParameter = /[A-Za-z]+[0-9]?/
            def optionalBound = /(?: : $identifier(?:<.+?>)?\??)?/
            def firstTypeParameterWithBound = /$firstTypeParameter$optionalBound/
            def typeIdentifier = /fun (?:<${firstTypeParameterWithBound}(?:, )?(.*?)> )?($identifier)\((?:$newLineAndIndent)?container: (AssertionContainer<.+?>)/
            def parameter = /,(?: |$newLineAndIndent)($identifier): ([^:]+?)/
            def returnType = /(?:$newLineAndIndent)?\)(:.+)/
 
            def patterns = (6..0).collect {
                def steps = (0..<it * 2).findAll { it % 2 == 0 }
                new Tuple3<Pattern, String, String>(
                    Pattern.compile(typeIdentifier + parameter * it + returnType),
                    /def $2[$1]\(/ + steps.collect { /$${it + 4}: $${it + 5}/ }.join(", ") + /\)$${it * 2 + 4} =/ + (it > 1 ? "$ln        " : " "),
                    /.$2\(container/ + (it > 0 ? ", " : "") + steps.collect { /$${it + 4}/ }.join(", ") + /\)/
                )
            }

            interfaces.forEach { input ->
                def type = getType(input)
                def uncapitalized = type.uncapitalize()
                def output = new File("$generatedPath/${uncapitalized}.scala")
                def content = input.text
                def interfaceName = "${type}Assertions"
                def implValName = "${type}Kt"

                def firstMethod = content.find(/fun <.+?> /)
                String[] arr
                String typeParameters
                if (firstMethod != null) {
                    typeParameters = firstMethod.substring(4, firstMethod.length() - 1)
                    arr = [
                            typeParameters
                                .replaceAll(/ : Any\??/, '')
                                .replaceAll(':', '<:')
                                .replaceAll(/<\*>/,'[_]'),
                            typeParameters.substring(1).find(identifier)
                        ]
                } else {
                    def firstMethodWithoutTp = content.find(/fun $identifier\((?:$newLineAndIndent)?container: AssertionContainer<.+?>/)
                    def a = 'AssertionContainer<'
                    def match = firstMethodWithoutTp.find(/${a}.+?>/)
                    arr = ['', match.substring(a.length(), match.length()-1)]
                }

                def (typeParameterList, containerParameter) = arr
                def classSignature = "class ${type}Logic$typeParameterList(container: AssertionContainer[$containerParameter]) {"
                String tmp = content
                  .replaceAll("package ${kotlinPackagePath.replace('/','.')}", "package ${packagePath.replace('/', '.')}")
                  .replaceAll(
                    /($newLine\/\*\*[\S\s]+?\*\/)?${newLine}interface $interfaceName \{/,
                    """\
                    import ch.tutteli.atrium.logic.${type}Kt
                    import ch.tutteli.atrium.scala2.logic._

                    $classSignature
                    """.stripIndent().replace("\n", ln)
                    )
                patterns.forEach { triple ->
                    tmp = tmp.replaceAll(triple.first, triple.second + implValName + triple.third)
                }

                def afterFirstTp = ''
                if (typeParameters != null) {
                    def firstLength = typeParameters.find(/<$identifier$optionalBound/).length() 
                    def length = typeParameters.length()
                    def rest = typeParameters.substring(firstLength + 2 < length ? firstLength + 2 : firstLength, length  - 1)
                    if (rest != '') {
                        afterFirstTp = /(?:${rest})?/
                    }
                }
                println("$type afterFirst $afterFirstTp")

                String generatedContent = tmp
                    .replaceAll(/(def $identifier)\[$afterFirstTp\]/, /$1/)
                    .replaceAll(/ : Any/,'')
                    .replaceAll(/(<|, )in ([A-Z])/, /$1$2/)
                    .replaceAll(/\.\(\)/, '')
                    .replaceAll('->', '=>')
                    .replaceAll(/\(([^\(\)]+?)\)\?/, /$1/)
                    .replaceAll(/\?/, '')
                    .replaceAll(/(\[|$identifier)</, /$1[/)
                    .replaceAll(/($identifier)>/, /$1]/)
                    .replaceAll(/\]>/, /]]/)
                    .replaceAll(/import kotlin.reflect.K(Property|Function)[0-9]${newLine}/, '')
                    .replaceAll(/K(?:Property|Function)([0-9])/, /Function$1/)
                    .replaceAll(/@file:Suppress\([^\)]+?\)${newLine}/, '')
                if(type == 'throwable'){
                    println('generatedContent')
                }
                output.withWriter('utf-8') { w ->
                    w << header
                    w << generatedContent
                }
                return;
            }
        }
    }
}

ext {
    createGenerateLogicTask = this.&createGenerateLogicTask
    generatedFolder = "src/generated/scala"
}
